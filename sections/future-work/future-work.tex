\section{Future Work}

The exemplary implementation that was done as part of this thesis is mainly a proof of concept. It demonstrates the capabilities of the outlined approach for statically analyzing JavaScript programs to derive control flow graphs. Some of the limitations described in section \ref{sec:limitations} (``\nameref{sec:limitations}''), such as the highly dynamic nature of the language, are inherent to JavaScript and therefore cannot be altered. Other aspects, however, have simply not been implemented in the Styx core library, mostly due to lack of time.

One such area that would benefit from further future work is the proper tracking of identifiers across scopes. When a function declares a variable or function with the name of a variable or function that is already used in an outer scope, the new local declaration \emph{shadows} the outer one. Within the inner function scope, all references to the shadowed identifier will be resolved to the new local binding. The Styx core library could keep track of variable and function declarations across all scopes and assign a unique name to each identifier. Currently, the caller of the library must manage variable declarations itself to detect shadowing in nested scopes. Unique identifier names would simplify disambiguation of bindings in the control flow graph.

Another area that might become increasingly interesting in the future is support for ECMAScript 2015 \cite{es2015-spec} language constructs. When work on the Styx core library started, ECMAScript 5.1 \cite{es5-spec} was the most recent language version standardized by Ecma International and thus became the targeted version for control flow analysis. New language features, such as default values or destructuring, must be supported in order to reflect program semantics correctly. This would require rewriting and extending the Styx core library. Esprima \cite{esprima}, the JavaScript parser, and ESTree \cite{estree-spec}, the specification of the abstract syntax tree format, already support ECMAScript 2015.

Finally, the Styx core library could be extended to deal with implicitly thrown errors as well. The control flow graphs currently only contain edges for explicitly thrown exceptions, as is discussed in section \ref{sec:implicitly-thrown-errors} (``\nameref{sec:implicitly-thrown-errors}''). Some operations might throw errors in certain cases, for instance when attempting to access a property of an object that is \code{null}. In contrast, other operations never throw an error, e.g. negating an existing value using the unary \code{!} operator. For some data flow analyses, it might be helpful to explicitly add all possible error edges to the control flow graph. It would then be possible, for example, to analyze whether a function is guaranteed to never result in an error (apart from unforeseeable runtime errors like program termination due to lack of memory). In general, the Styx core library could be extended such that it annotates the control flow graphs derived with additional attributes (if that data is available) to enable further data flow analyses.
